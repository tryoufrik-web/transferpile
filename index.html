<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>WebDrop Pro</title>
<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
<style>
body{font-family:Arial;background:#0f172a;color:white;text-align:center;padding:20px}
button,input{padding:10px;margin:5px;border-radius:8px;border:none}
button{background:#22c55e;color:white;cursor:pointer}
.device{background:#1e293b;padding:8px;margin:5px;border-radius:8px;cursor:pointer}
.progress{width:100%;background:#1e293b;height:20px;border-radius:10px;margin-top:10px}
.bar{height:100%;width:0%;background:#22c55e;border-radius:10px}
</style>
</head>
<body>

<h2>ðŸš€ WebDrop Pro</h2>

<input id="roomInput" placeholder="Room Code">
<button onclick="joinRoom()">Join Room</button>

<div id="qrcode"></div>

<h3>Devices</h3>
<div id="devices"></div>

<input type="file" id="fileInput" multiple>
<button onclick="sendFiles()">Send</button>

<div class="progress">
<div class="bar" id="progressBar"></div>
</div>
<p id="speedText"></p>

<script>
let peer;
let connections = {};
let isHost = false;
let isTransferring = false;
let reconnectAttempts = 0;
const MAX_RECONNECT = 5;
let selectedTarget = null;
let receivedBuffers = [];
let currentMeta = null;

const CHUNK_SIZES = [256*1024,512*1024,1024*1024];
let currentChunkSize = CHUNK_SIZES[0];
const MAX_PARALLEL = navigator.hardwareConcurrency > 4 ? 2 : 1;

function joinRoom(){
    const code = document.getElementById("roomInput").value;
    if(!code) return alert("Enter room code");

    peer = new Peer(null,{
        config:{
            iceServers:[
                {urls:'stun:stun.l.google.com:19302'},
                {urls:'stun:stun.cloudflare.com:3478'},
                {
                  urls:'turn:openrelay.metered.ca:80',
                  username:'openrelayproject',
                  credential:'openrelayproject'
                }
            ]
        }
    });

    peer.on("open", id=>{
        tryConnectHost(code);
        generateQR(code);
    });

    peer.on("connection", conn=>{
        setupConnection(conn);
    });
}

function tryConnectHost(code){
    const conn = peer.connect("room-"+code);

    const timeout = setTimeout(()=>{
        becomeHost(code);
    },2000);

    conn.on("open",()=>{
        clearTimeout(timeout);
        setupConnection(conn);
    });
}

function becomeHost(code){
    isHost = true;
    peer.destroy();
    peer = new Peer("room-"+code);

    peer.on("connection", conn=>{
        setupConnection(conn);
    });
}

function setupConnection(conn){
    connections[conn.peer] = conn;
    updateDeviceList();

    conn.on("data", data=>{
        if(data.type==="device-list"){
            renderDevices(data.list);
        }
        if(data.type==="meta"){
            currentMeta = data;
            receivedBuffers=[];
        }
        if(data.type==="chunk"){
            receivedBuffers.push(data.data);
        }
        if(data.type==="end"){
            const blob = new Blob(receivedBuffers);
            const a=document.createElement("a");
            a.href=URL.createObjectURL(blob);
            a.download=currentMeta.name;
            a.click();
            receivedBuffers=[];
            currentMeta=null;
        }
    });

    conn.on("close",()=>{
        delete connections[conn.peer];
        updateDeviceList();
        if(!isTransferring && reconnectAttempts<MAX_RECONNECT){
            reconnectAttempts++;
            setTimeout(()=>location.reload(),1500);
        }
    });

    broadcastDeviceList();
}

function updateDeviceList(){
    const list = Object.keys(connections);
    renderDevices(list);
}

function renderDevices(list){
    const div=document.getElementById("devices");
    div.innerHTML="";
    list.forEach(id=>{
        const d=document.createElement("div");
        d.className="device";
        d.innerText=id;
        d.onclick=()=>selectedTarget=id;
        div.appendChild(d);
    });
}

function broadcastDeviceList(){
    safeBroadcast({type:"device-list",list:Object.keys(connections)});
}

function safeBroadcast(data){
    Object.values(connections).forEach(conn=>{
        if(conn.open) conn.send(data);
    });
}

async function sendFiles(){
    if(isTransferring) return;
    if(!selectedTarget) return alert("Select device first");

    const files=document.getElementById("fileInput").files;
    if(!files.length) return;

    isTransferring=true;
    const conn=connections[selectedTarget];

    for(let i=0;i<files.length;i+=MAX_PARALLEL){
        const batch=[...files].slice(i,i+MAX_PARALLEL);
        await Promise.all(batch.map(file=>sendFile(file,conn)));
    }

    isTransferring=false;
}

function adjustChunkSize(speed){
    if(speed>5*1024*1024) currentChunkSize=CHUNK_SIZES[2];
    else if(speed>1*1024*1024) currentChunkSize=CHUNK_SIZES[1];
    else currentChunkSize=CHUNK_SIZES[0];

    if(currentChunkSize>1024*1024)
        currentChunkSize=1024*1024;
}

async function sendFile(file,conn){
    conn.send({type:"meta",name:file.name,size:file.size});
    let offset=0;
    let startTime=Date.now();

    while(offset<file.size){
        const slice=file.slice(offset,offset+currentChunkSize);
        const buffer=await slice.arrayBuffer();
        conn.send({type:"chunk",data:buffer});
        offset+=currentChunkSize;

        const percent=(offset/file.size)*100;
        document.getElementById("progressBar").style.width=percent+"%";

        const elapsed=(Date.now()-startTime)/1000;
        const speed=offset/elapsed;
        document.getElementById("speedText").innerText=
            (speed/1024).toFixed(2)+" KB/s";

        adjustChunkSize(speed);
    }

    conn.send({type:"end"});
}

function generateQR(code){
    const url=location.origin+location.pathname+"?room="+code;
    QRCode.toCanvas(document.getElementById("qrcode"),url);
}

window.onload=()=>{
    const params=new URLSearchParams(location.search);
    if(params.get("room")){
        document.getElementById("roomInput").value=params.get("room");
        joinRoom();
    }
}
</script>

</body>
</html>
